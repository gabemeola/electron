From bcffbef7eb7696034542c5b67038b17b11c3ce25 Mon Sep 17 00:00:00 2001
From: Maggie Chen <magchen@chromium.org>
Date: Fri, 18 Nov 2022 00:39:06 +0000
Subject: [PATCH] [M109 Merge] Disable an overlay feature NoUndamagedOverlayPromotion on Windows

Temporarily disable the feature NoUndamagedOverlayPromotion that prevents undamaged overlays from being promoted when there are more YUV overlays in a frame than GPU hardware can support. It's suspected that this feature causes flickers in multiple video playbacks.

A new feature flag NoUndamagedOverlayPromotion is added and disabled by default.

This feature was originally added in https://chromium-review.googlesource.com/c/chromium/src/+/3649447

(cherry picked from commit 2f983a19358d3da75d1f97d11c6bcaf58f9ed5f2)

Bug: 1366848, 1371480
Change-Id: Idcce2c8cddb7d5050c975e28d1eb7484d295da28
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/4023335
Auto-Submit: Maggie Chen <magchen@chromium.org>
Reviewed-by: vikas soni <vikassoni@chromium.org>
Commit-Queue: Maggie Chen <magchen@chromium.org>
Cr-Original-Commit-Position: refs/heads/main@{#1071949}
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/4035031
Commit-Queue: Rubber Stamper <rubber-stamper@appspot.gserviceaccount.com>
Reviewed-by: Maggie Chen <magchen@chromium.org>
Bot-Commit: Rubber Stamper <rubber-stamper@appspot.gserviceaccount.com>
Cr-Commit-Position: refs/branch-heads/5414@{#121}
Cr-Branched-From: 4417ee59d7bf6df7a9c9ea28f7722d2ee6203413-refs/heads/main@{#1070088}
---

diff --git a/components/viz/service/display/dc_layer_overlay.cc b/components/viz/service/display/dc_layer_overlay.cc
index 3dfb2c8..652bda5 100644
--- a/components/viz/service/display/dc_layer_overlay.cc
+++ b/components/viz/service/display/dc_layer_overlay.cc
@@ -483,7 +483,9 @@
     bool skip_initialization_for_testing)
     : has_overlay_support_(skip_initialization_for_testing),
       allowed_yuv_overlay_count_(allowed_yuv_overlay_count),
-      debug_settings_(debug_settings) {
+      debug_settings_(debug_settings),
+      no_undamaged_overlay_promotion_(base::FeatureList::IsEnabled(
+          features::kNoUndamagedOverlayPromotion)) {
   if (!skip_initialization_for_testing) {
     UpdateHasHwOverlaySupport();
     UpdateSystemHDRStatus();
@@ -786,14 +788,21 @@
             has_overlay_support_, allowed_yuv_overlay_count_,
             processed_yuv_overlay_count_, resource_provider);
         yuv_quads_in_quad_list++;
-        if (it->shared_quad_state->overlay_damage_index.has_value() &&
-            !surface_damage_rect_list_[it->shared_quad_state
-                                           ->overlay_damage_index.value()]
-                 .IsEmpty()) {
-          damaged_yuv_quads_in_quad_list++;
+
+        if (no_undamaged_overlay_promotion_) {
+          if (it->shared_quad_state->overlay_damage_index.has_value() &&
+              !surface_damage_rect_list_[it->shared_quad_state
+                                             ->overlay_damage_index.value()]
+                   .IsEmpty()) {
+            damaged_yuv_quads_in_quad_list++;
+            if (result == DC_LAYER_SUCCESS)
+              processed_yuv_overlay_count_++;
+          }
+        } else {
           if (result == DC_LAYER_SUCCESS)
             processed_yuv_overlay_count_++;
         }
+
         break;
       case DrawQuad::Material::kTextureContent: {
         const TextureDrawQuad* tex_quad = TextureDrawQuad::MaterialCast(*it);
@@ -862,13 +871,18 @@
   // overlays
   bool reject_overlays = false;
   if (yuv_quads_in_quad_list > 1 && !has_protected_video_or_texture_overlays) {
-    if (damaged_yuv_quads_in_quad_list == processed_yuv_overlay_count_) {
-      frames_since_last_qualified_multi_overlays_++;
+    if (no_undamaged_overlay_promotion_) {
+      if (damaged_yuv_quads_in_quad_list == processed_yuv_overlay_count_) {
+        frames_since_last_qualified_multi_overlays_++;
+      } else {
+        frames_since_last_qualified_multi_overlays_ = 0;
+      }
+      reject_overlays = frames_since_last_qualified_multi_overlays_ <=
+                        kDCLayerFramesDelayedBeforeOverlay;
     } else {
-      frames_since_last_qualified_multi_overlays_ = 0;
+      if (yuv_quads_in_quad_list != processed_yuv_overlay_count_)
+        reject_overlays = true;
     }
-    reject_overlays = frames_since_last_qualified_multi_overlays_ <=
-                      kDCLayerFramesDelayedBeforeOverlay;
   }
 
   // A YUV quad might be rejected later due to not allowed as an underlay.
@@ -900,8 +914,9 @@
             .IsEmpty();
 
     if (yuv_quads_in_quad_list > allowed_yuv_overlay_count_ &&
-        !has_protected_video_or_texture_overlays &&
-        it->material == DrawQuad::Material::kYuvVideoContent && undamaged) {
+        !has_protected_video_or_texture_overlays && undamaged &&
+        no_undamaged_overlay_promotion_ &&
+        it->material == DrawQuad::Material::kYuvVideoContent) {
       RecordDCLayerResult(DC_LAYER_FAILED_NOT_DAMAGED, it);
       continue;
     }
diff --git a/components/viz/service/display/dc_layer_overlay.h b/components/viz/service/display/dc_layer_overlay.h
index f02473b..13f0b07 100644
--- a/components/viz/service/display/dc_layer_overlay.h
+++ b/components/viz/service/display/dc_layer_overlay.h
@@ -220,6 +220,7 @@
   // List of clear video content candidate bounds.
   std::vector<gfx::Rect> previous_frame_overlay_candidate_rects_{};
   int frames_since_last_overlay_candidate_rects_change_ = 0;
+  bool no_undamaged_overlay_promotion_;
 
   THREAD_CHECKER(thread_checker_);
 };
diff --git a/components/viz/service/display/overlay_dc_unittest.cc b/components/viz/service/display/overlay_dc_unittest.cc
index 7f4507e..cc233ff0 100644
--- a/components/viz/service/display/overlay_dc_unittest.cc
+++ b/components/viz/service/display/overlay_dc_unittest.cc
@@ -827,8 +827,10 @@
 
 // If there are multiple yuv overlay quad candidates, no overlay will be
 // promoted to save power.
-TEST_F(DCLayerOverlayTest, MultipleYUVOverlay) {
-  base::test::ScopedFeatureList feature_list;
+TEST_F(DCLayerOverlayTest, MultipleYUVOverlays) {
+  base::test::ScopedFeatureList scoped_feature_list;
+  scoped_feature_list.InitAndEnableFeature(
+      features::kNoUndamagedOverlayPromotion);
   {
     auto pass = CreateRenderPass();
     CreateOpaqueQuadAt(resource_provider_.get(),
diff --git a/gpu/config/gpu_finch_features.cc b/gpu/config/gpu_finch_features.cc
index 6a4dceb..e898eb1 100644
--- a/gpu/config/gpu_finch_features.cc
+++ b/gpu/config/gpu_finch_features.cc
@@ -179,6 +179,10 @@
 BASE_FEATURE(kDisableVideoOverlayIfMoving,
              "DisableVideoOverlayIfMoving",
              base::FEATURE_DISABLED_BY_DEFAULT);
+
+BASE_FEATURE(kNoUndamagedOverlayPromotion,
+             "NoUndamagedOverlayPromotion",
+             base::FEATURE_DISABLED_BY_DEFAULT);
 #endif
 
 #if BUILDFLAG(IS_MAC)
diff --git a/gpu/config/gpu_finch_features.h b/gpu/config/gpu_finch_features.h
index a0ce343..bf0236b 100644
--- a/gpu/config/gpu_finch_features.h
+++ b/gpu/config/gpu_finch_features.h
@@ -42,6 +42,8 @@
 GPU_EXPORT BASE_DECLARE_FEATURE(kGpuProcessHighPriorityWin);
 
 GPU_EXPORT BASE_DECLARE_FEATURE(kDisableVideoOverlayIfMoving);
+
+GPU_EXPORT BASE_DECLARE_FEATURE(kNoUndamagedOverlayPromotion);
 #endif
 
 #if BUILDFLAG(IS_MAC)
